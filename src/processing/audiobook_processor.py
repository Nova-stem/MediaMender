import logging
import subprocess
import urllib.request
import urllib.parse
import shutil
import json
import time
from pathlib import Path

from src.preferences import _load_config
from src.processing.common_utils import (
    sanitize_filename, move_to_trash, generate_normal_subtitles_from_audio,
    parse_chapters_from_srt, get_expected_chapter_count,
    fetch_openlibrary_metadata, build_audiobook_filename, get_output_path_for_media
)


def process_audiobook(file_path: Path, base_output_dir: Path, dry_run: bool = False):
    logging.info(f"[Audiobook] Starting: {file_path.name}")
    output_dir = get_output_path_for_media("audiobook", {}, base_output_dir)

    config = _load_config()
    allow_generation = config.get("allow_generation", False)
    whisper_model = config.get("whisper_model", "base")

    # Step 3: Fetch metadata
    title = sanitize_filename(file_path.stem)
    metadata = fetch_openlibrary_metadata(title)
    book_title = metadata.get("title", title)
    author = metadata.get("author", "Unknown")
    series = metadata.get("series")
    cover_url = metadata.get("cover_url")
    cover_path = None

    # Step 6: Build ffmpeg command
    metadata.update({
        "title": book_title,
        "author": author,
        "series_name": series or "",
        "series_number": metadata.get("series_number", "")
    })
    filename = sanitize_filename(build_audiobook_filename(metadata))
    m4b_path = output_dir / filename
    logging.info(f"ðŸŽ§ Output filename: {m4b_path.name}")

    if m4b_path.exists():
        logging.info(f"Skipping audiobook (already exists): {m4b_path.name}")
        return

    if cover_url and not dry_run:
        try:
            cover_path = output_dir / "cover.jpg"
            urllib.request.urlretrieve(cover_url, cover_path)
        except Exception as e:
            logging.warning(f"Failed to download cover image: {e}")
            cover_path = None

    # Step 1: Detect single vs multi-part
    parts = []
    if file_path.is_dir():
        parts = sorted(file_path.glob("*.mp3")) + sorted(file_path.glob("*.m4a"))
        if not parts:
            logging.warning(f"No audio parts found in {file_path}")
            return
    else:
        parts = [file_path]

    # Step 2: Merge if needed
    merged_path = output_dir / (file_path.stem + ".merged.m4a")
    if len(parts) > 1:
        list_path = output_dir / "parts.txt"
        with list_path.open("w", encoding="utf-8") as f:
            for p in parts:
                f.write(f"file '{p.as_posix()}'\n")
        if dry_run:
            logging.info(f"[DRY RUN] Would merge to: {merged_path}")
        else:
            subprocess.run([
                "ffmpeg", "-f", "concat", "-safe", "0", "-i", str(list_path),
                "-c", "copy", str(merged_path)
            ], check=True)
        list_path.unlink()
    else:
        merged_path = parts[0]

    # Step 4: Generate SRT + parse chapters
    srt_path = output_dir / f"{file_path.stem}.srt"
    chapters = []
    if allow_generation and not dry_run:
        try:
            srt_path = generate_normal_subtitles_from_audio(merged_path, srt_path, whisper_model, dry_run)
            chapters = parse_chapters_from_srt(srt_path)
        except Exception as e:
            logging.warning(f"Whisper transcription failed: {e}")
    elif not allow_generation:
        logging.info(f"Subtitle generation disabled. Enable it in Preferences for better chapter detection.")

    # Step 5: Expected chapter sanity check
    expected_count = get_expected_chapter_count(book_title)
    if expected_count and (len(chapters) < 0.5 * expected_count or len(chapters) > 2.5 * expected_count):
        logging.warning(f"Chapter mismatch. Expected ~{expected_count}, detected {len(chapters)}. Skipping chapters.")
        chapters = []

    cmd = [
        "ffmpeg", "-i", str(merged_path),
        "-vn", "-c:a", "aac", "-b:a", "64k",
        "-metadata", f"title={book_title}",
        "-metadata", f"author={author}",
        "-metadata", f"album={series or ''}",
        "-metadata", f"genre=Audiobook",
        "-metadata", f"comment=Generated by MediaMender"
    ]

    if cover_path and cover_path.exists():
        cmd += ["-i", str(cover_path), "-map", "0:a", "-map", "1", "-c:v", "jpeg", "-disposition:v", "attached_pic"]

    cmd.append(str(m4b_path))

    if dry_run:
        logging.info(f"[DRY RUN] Would create M4B: {m4b_path}")
        return

    subprocess.run(cmd, check=True)

    # Step 7: Cleanup
    if cover_path and cover_path.exists():
        cover_path.unlink()

    if merged_path != parts[0] and merged_path.exists():
        move_to_trash(merged_path, dry_run)

    if srt_path.exists():
        move_to_trash(srt_path, dry_run)

    logging.info(f"[Audiobook] Finished: {m4b_path.name}")
